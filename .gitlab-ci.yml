stages:
  - test-pipeline
  - build-pipeline
  - run-pipeline
  - update-model
  - test-api
  - build-api
  - deploy-api

# Change pip's cache directory to be inside the project directory since we can
# only cache local items.
variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  HEROKU_STAGING_URL: https://$HEROKU_STAGING_APP.herokuapp.com/
  # tells pipenv where to keep virtualenvs
  WORKON_HOME: venv/
  API_VERSION_PATH: "packages/api/VERSION"
  # docker image details
  PIPELINE_IMAGE_NAME: password-pipeline
  PIPELINE_IMAGE_REF: $CI_REGISTRY_IMAGE/$PIPELINE_IMAGE_NAME:$CI_COMMIT_REF_SLUG
  PIPELINE_IMAGE_TAG: $CI_REGISTRY_IMAGE/$PIPELINE_IMAGE_NAME:$CI_COMMIT_SHA
  APP_IMAGE_NAME: password-app
  APP_IMAGE_REF: $CI_REGISTRY_IMAGE/$APP_IMAGE_NAME:$CI_COMMIT_REF_SLUG
  APP_IMAGE_TAG: $CI_REGISTRY_IMAGE/$APP_IMAGE_NAME:$CI_COMMIT_SHA

# Pip's cache doesn't store the python packages
# https://pip.pypa.io/en/stable/reference/pip_install/#caching
# If you want to also cache the installed packages, you have to install
# them in a virtualenv and cache it as well.
cache:
 paths:
   - .cache/pip
   - venv/
   - .pyenv/cache

run-pytest-on-pipeline:
  stage: test-pipeline
  script:
    - echo
  only:
    changes:
      - packages/pipeline/**/*
  except:
    - schedules

build-pipeline-docker-image:
  image: docker:19.03.12
  services:
    - docker:19.03.12-dind
  stage: build-pipeline
  script:
    - echo "Building docker image"
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - docker build -t $PIPELINE_IMAGE_TAG .
    - docker push $PIPELINE_IMAGE_TAG
    - docker image tag $PIPELINE_IMAGE_TAG $PIPELINE_IMAGE_REF
    - docker push $PIPELINE_IMAGE_REF
  only:
    changes:
      - packages/pipeline/**/*
  except:
    - schedules

train-model:
  stage: run-pipeline
  image: $PIPELINE_IMAGE_REF
  script:
    - sh -ux ./scripts/run_pipeline.sh
  only:
    changes:
      - packages/pipeline/**/*

update-model-if-qualified:
  stage: update-model
  script:
    # TODO: bump model version instead of VERSION (which could be a package version)
    # bump semver version
    - export VERSION=$(cat $API_VERSION_PATH | awk -F. -v OFS=. 'NF==1{print ++$NF}; NF>1{$NF=sprintf("%0*d", length($NF), ($NF+1)); print}')
    - echo $VERSION
    - echo $VERSION > $API_VERSION_PATH
    # push changes to git
    - git remote set-url origin https://dmiasport:${CI_PUSH_TOKEN}@gitlab.com/${CI_PROJECT_PATH}.git
    - git config --global user.email "dmiasport@gmail.com"
    - git config --global user.name "Gitlab Runner"
    - git add $API_VERSION_PATH
    - git commit -m "bump api version to ${VERSION}"
    - git push --follow-tags origin HEAD:$CI_COMMIT_REF_NAME
  only:
    changes:
      - packages/pipeline/**/*

run-pytest-on-api:
  stage: test-api
  script:
    - echo
  only:
    changes:
      - packages/app/**/*
  except:
    - schedules

build-api-docker-image:
  stage: build-api
  image: docker:19.03.12
  services:
    - docker:19.03.12-dind
  script:
    - echo "Building docker image"
    - cd package
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - docker build -t $APP_IMAGE_TAG .
    - docker push $APP_IMAGE_TAG
    - docker image tag $APP_IMAGE_TAG $APP_IMAGE_REF
    - docker push $APP_IMAGE_REF
  only:
    changes:
      - packages/app/**/*
  except:
    - schedules

deploy-api-docker-image-staging:
  stage: deploy-api
  image: node:15.4.0-buster
  script:
    - apt-get update -qy
    - apt-get install -y git ruby-dev tree
    - gem install dpl
    - cd packages/app
    - tree -a .
    # this is required because heroku use pip 9.0.2 with Pipfile.lock for python 3.8 runtime
    - python3 -V
    - "apt-get update || : && apt-get install python3-pip -y"
    - pip3 install pipenv
    # install pyenv to provide python 3.8 for pipenv
    - curl https://pyenv.run | bash
    - export PATH="/root/.pyenv/bin:$PATH"
    - eval "$(pyenv init -)"
    - eval "$(pyenv virtualenv-init -)"
    - mkdir -p $(pyenv root)/cache
    - pyenv install 3.8.5
    - pipenv lock -r > requirements.txt
    # do the actual deploy
    - dpl --provider=heroku --app=$HEROKU_STAGING_APP --api-key=$HEROKU_STAGING_API_KEY --skip-cleanup
    - curl $HEROKU_STAGING_URL
  environment:
    name: staging
    url: $HEROKU_STAGING_URL
  only:
    changes:
      - packages/app/**/*
  except:
    - schedules
